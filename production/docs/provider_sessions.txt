I am working on the server subproject. I need to improve the provider workflow:
The Provider should be responsible for creating and managing one or more Provider Sessions, where each Provider Session represents a single remote WebSocket connection (or logical session) to the provider service. Each Provider Session has its own inbound events (events coming from the provider, such as transcripts, translations, synthesized audio, or control signals) and accepts outbound events (events sent to the provider, such as audio chunks, configuration updates, or turn/interrupt controls). This aligns naturally with how WebSocket providers behave and avoids overloading the term “client” with transport-specific meaning.

All Provider Session inbound events should be normalized into internal ProviderResponseEvents and pushed into a single provider-to-pipeline inbound queue owned by the Provider (or SessionPipeline). The SessionPipeline does not need to know which Provider Session produced an event; it only relies on normalized metadata on the event (e.g., target_language, source_participant_id, event type). This preserves a single, linear path back toward ACS and avoids reintroducing per-session or per-participant routing complexity.

The Provider itself acts as the coordinator: it decides how many Provider Sessions are required (for example, one per target language), creates them on demand, fans out outbound requests to the appropriate Provider Sessions, and merges inbound events from all sessions into the shared inbound queue. Provider Sessions must not communicate with ACS or the SessionPipeline directly; they only emit normalized events upward to the Provider, which enforces isolation and consistency.

This approach is sound, WebSocket-native, and consistent with your architectural goal: one SessionPipeline, one provider integration surface, many provider sessions when needed, and one unified path back to ACS. It also keeps the current pipeline intact and makes future providers easier to add without expanding routing logic elsewhere.